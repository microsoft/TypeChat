//*******************************************************************************
// Copyright (c) 2022 Contributors to the Eclipse Foundation
//
// See the NOTICE file(s) distributed with this work for additional
// information regarding copyright ownership.
//
// This program and the accompanying materials are made available under the
// terms of the Apache License 2.0 which is available at
// http://www.apache.org/licenses/LICENSE-2.0
//
// SPDX-License-Identifier: Apache-2.0
//******************************************************************************

// @generated by protoc-gen-es v1.10.0 with parameter "target=ts"
// @generated from file kuksa/val/v1/types.proto (package kuksa.val.v1, syntax proto3)
/* eslint-disable */
// @ts-nocheck

// I added V1 as in databroker. Is this good practice?

import type { BinaryReadOptions, FieldList, JsonReadOptions, JsonValue, PartialMessage, PlainMessage } from "@bufbuild/protobuf";
import { Message, proto3, Timestamp } from "@bufbuild/protobuf";

/**
 * VSS Data type of a signal
 *
 * Protobuf doesn't support int8, int16, uint8 or uint16.
 * These are mapped to int32 and uint32 respectively.
 *
 *
 * @generated from enum kuksa.val.v1.DataType
 */
export enum DataType {
  /**
   * @generated from enum value: DATA_TYPE_UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,

  /**
   * @generated from enum value: DATA_TYPE_STRING = 1;
   */
  STRING = 1,

  /**
   * @generated from enum value: DATA_TYPE_BOOLEAN = 2;
   */
  BOOLEAN = 2,

  /**
   * @generated from enum value: DATA_TYPE_INT8 = 3;
   */
  INT8 = 3,

  /**
   * @generated from enum value: DATA_TYPE_INT16 = 4;
   */
  INT16 = 4,

  /**
   * @generated from enum value: DATA_TYPE_INT32 = 5;
   */
  INT32 = 5,

  /**
   * @generated from enum value: DATA_TYPE_INT64 = 6;
   */
  INT64 = 6,

  /**
   * @generated from enum value: DATA_TYPE_UINT8 = 7;
   */
  UINT8 = 7,

  /**
   * @generated from enum value: DATA_TYPE_UINT16 = 8;
   */
  UINT16 = 8,

  /**
   * @generated from enum value: DATA_TYPE_UINT32 = 9;
   */
  UINT32 = 9,

  /**
   * @generated from enum value: DATA_TYPE_UINT64 = 10;
   */
  UINT64 = 10,

  /**
   * @generated from enum value: DATA_TYPE_FLOAT = 11;
   */
  FLOAT = 11,

  /**
   * @generated from enum value: DATA_TYPE_DOUBLE = 12;
   */
  DOUBLE = 12,

  /**
   * @generated from enum value: DATA_TYPE_TIMESTAMP = 13;
   */
  TIMESTAMP = 13,

  /**
   * @generated from enum value: DATA_TYPE_STRING_ARRAY = 20;
   */
  STRING_ARRAY = 20,

  /**
   * @generated from enum value: DATA_TYPE_BOOLEAN_ARRAY = 21;
   */
  BOOLEAN_ARRAY = 21,

  /**
   * @generated from enum value: DATA_TYPE_INT8_ARRAY = 22;
   */
  INT8_ARRAY = 22,

  /**
   * @generated from enum value: DATA_TYPE_INT16_ARRAY = 23;
   */
  INT16_ARRAY = 23,

  /**
   * @generated from enum value: DATA_TYPE_INT32_ARRAY = 24;
   */
  INT32_ARRAY = 24,

  /**
   * @generated from enum value: DATA_TYPE_INT64_ARRAY = 25;
   */
  INT64_ARRAY = 25,

  /**
   * @generated from enum value: DATA_TYPE_UINT8_ARRAY = 26;
   */
  UINT8_ARRAY = 26,

  /**
   * @generated from enum value: DATA_TYPE_UINT16_ARRAY = 27;
   */
  UINT16_ARRAY = 27,

  /**
   * @generated from enum value: DATA_TYPE_UINT32_ARRAY = 28;
   */
  UINT32_ARRAY = 28,

  /**
   * @generated from enum value: DATA_TYPE_UINT64_ARRAY = 29;
   */
  UINT64_ARRAY = 29,

  /**
   * @generated from enum value: DATA_TYPE_FLOAT_ARRAY = 30;
   */
  FLOAT_ARRAY = 30,

  /**
   * @generated from enum value: DATA_TYPE_DOUBLE_ARRAY = 31;
   */
  DOUBLE_ARRAY = 31,

  /**
   * @generated from enum value: DATA_TYPE_TIMESTAMP_ARRAY = 32;
   */
  TIMESTAMP_ARRAY = 32,
}
// Retrieve enum metadata with: proto3.getEnumType(DataType)
proto3.util.setEnumType(DataType, "kuksa.val.v1.DataType", [
  { no: 0, name: "DATA_TYPE_UNSPECIFIED" },
  { no: 1, name: "DATA_TYPE_STRING" },
  { no: 2, name: "DATA_TYPE_BOOLEAN" },
  { no: 3, name: "DATA_TYPE_INT8" },
  { no: 4, name: "DATA_TYPE_INT16" },
  { no: 5, name: "DATA_TYPE_INT32" },
  { no: 6, name: "DATA_TYPE_INT64" },
  { no: 7, name: "DATA_TYPE_UINT8" },
  { no: 8, name: "DATA_TYPE_UINT16" },
  { no: 9, name: "DATA_TYPE_UINT32" },
  { no: 10, name: "DATA_TYPE_UINT64" },
  { no: 11, name: "DATA_TYPE_FLOAT" },
  { no: 12, name: "DATA_TYPE_DOUBLE" },
  { no: 13, name: "DATA_TYPE_TIMESTAMP" },
  { no: 20, name: "DATA_TYPE_STRING_ARRAY" },
  { no: 21, name: "DATA_TYPE_BOOLEAN_ARRAY" },
  { no: 22, name: "DATA_TYPE_INT8_ARRAY" },
  { no: 23, name: "DATA_TYPE_INT16_ARRAY" },
  { no: 24, name: "DATA_TYPE_INT32_ARRAY" },
  { no: 25, name: "DATA_TYPE_INT64_ARRAY" },
  { no: 26, name: "DATA_TYPE_UINT8_ARRAY" },
  { no: 27, name: "DATA_TYPE_UINT16_ARRAY" },
  { no: 28, name: "DATA_TYPE_UINT32_ARRAY" },
  { no: 29, name: "DATA_TYPE_UINT64_ARRAY" },
  { no: 30, name: "DATA_TYPE_FLOAT_ARRAY" },
  { no: 31, name: "DATA_TYPE_DOUBLE_ARRAY" },
  { no: 32, name: "DATA_TYPE_TIMESTAMP_ARRAY" },
]);

/**
 * Entry type
 *
 * @generated from enum kuksa.val.v1.EntryType
 */
export enum EntryType {
  /**
   * @generated from enum value: ENTRY_TYPE_UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,

  /**
   * @generated from enum value: ENTRY_TYPE_ATTRIBUTE = 1;
   */
  ATTRIBUTE = 1,

  /**
   * @generated from enum value: ENTRY_TYPE_SENSOR = 2;
   */
  SENSOR = 2,

  /**
   * @generated from enum value: ENTRY_TYPE_ACTUATOR = 3;
   */
  ACTUATOR = 3,
}
// Retrieve enum metadata with: proto3.getEnumType(EntryType)
proto3.util.setEnumType(EntryType, "kuksa.val.v1.EntryType", [
  { no: 0, name: "ENTRY_TYPE_UNSPECIFIED" },
  { no: 1, name: "ENTRY_TYPE_ATTRIBUTE" },
  { no: 2, name: "ENTRY_TYPE_SENSOR" },
  { no: 3, name: "ENTRY_TYPE_ACTUATOR" },
]);

/**
 * A `View` specifies a set of fields which should
 * be populated in a `DataEntry` (in a response message)
 *
 * @generated from enum kuksa.val.v1.View
 */
export enum View {
  /**
   * Unspecified. Equivalent to VIEW_CURRENT_VALUE unless `fields` are explicitly set.
   *
   * @generated from enum value: VIEW_UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,

  /**
   * Populate DataEntry with value.
   *
   * @generated from enum value: VIEW_CURRENT_VALUE = 1;
   */
  CURRENT_VALUE = 1,

  /**
   * Populate DataEntry with actuator target.
   *
   * @generated from enum value: VIEW_TARGET_VALUE = 2;
   */
  TARGET_VALUE = 2,

  /**
   * Populate DataEntry with metadata.
   *
   * @generated from enum value: VIEW_METADATA = 3;
   */
  METADATA = 3,

  /**
   * Populate DataEntry only with requested fields.
   *
   * @generated from enum value: VIEW_FIELDS = 10;
   */
  FIELDS = 10,

  /**
   * Populate DataEntry with everything.
   *
   * @generated from enum value: VIEW_ALL = 20;
   */
  ALL = 20,
}
// Retrieve enum metadata with: proto3.getEnumType(View)
proto3.util.setEnumType(View, "kuksa.val.v1.View", [
  { no: 0, name: "VIEW_UNSPECIFIED" },
  { no: 1, name: "VIEW_CURRENT_VALUE" },
  { no: 2, name: "VIEW_TARGET_VALUE" },
  { no: 3, name: "VIEW_METADATA" },
  { no: 10, name: "VIEW_FIELDS" },
  { no: 20, name: "VIEW_ALL" },
]);

/**
 * A `Field` corresponds to a specific field of a `DataEntry`.
 *
 * It can be used to:
 *   * populate only specific fields of a `DataEntry` response.
 *   * specify which fields of a `DataEntry` should be set as
 *     part of a `Set` request.
 *   * subscribe to only specific fields of a data entry.
 *   * convey which fields of an updated `DataEntry` have changed.
 *
 * @generated from enum kuksa.val.v1.Field
 */
export enum Field {
  /**
   * "*" i.e. everything
   *
   * @generated from enum value: FIELD_UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,

  /**
   * path
   *
   * @generated from enum value: FIELD_PATH = 1;
   */
  PATH = 1,

  /**
   * value
   *
   * @generated from enum value: FIELD_VALUE = 2;
   */
  VALUE = 2,

  /**
   * actuator_target
   *
   * @generated from enum value: FIELD_ACTUATOR_TARGET = 3;
   */
  ACTUATOR_TARGET = 3,

  /**
   * metadata.*
   *
   * @generated from enum value: FIELD_METADATA = 10;
   */
  METADATA = 10,

  /**
   * metadata.data_type
   *
   * @generated from enum value: FIELD_METADATA_DATA_TYPE = 11;
   */
  METADATA_DATA_TYPE = 11,

  /**
   * metadata.description
   *
   * @generated from enum value: FIELD_METADATA_DESCRIPTION = 12;
   */
  METADATA_DESCRIPTION = 12,

  /**
   * metadata.entry_type
   *
   * @generated from enum value: FIELD_METADATA_ENTRY_TYPE = 13;
   */
  METADATA_ENTRY_TYPE = 13,

  /**
   * metadata.comment
   *
   * @generated from enum value: FIELD_METADATA_COMMENT = 14;
   */
  METADATA_COMMENT = 14,

  /**
   * metadata.deprecation
   *
   * @generated from enum value: FIELD_METADATA_DEPRECATION = 15;
   */
  METADATA_DEPRECATION = 15,

  /**
   * metadata.unit
   *
   * @generated from enum value: FIELD_METADATA_UNIT = 16;
   */
  METADATA_UNIT = 16,

  /**
   * metadata.value_restriction.*
   *
   * @generated from enum value: FIELD_METADATA_VALUE_RESTRICTION = 17;
   */
  METADATA_VALUE_RESTRICTION = 17,

  /**
   * metadata.actuator.*
   *
   * @generated from enum value: FIELD_METADATA_ACTUATOR = 20;
   */
  METADATA_ACTUATOR = 20,

  /**
   * metadata.sensor.*
   *
   * @generated from enum value: FIELD_METADATA_SENSOR = 30;
   */
  METADATA_SENSOR = 30,

  /**
   * metadata.attribute.*
   *
   * @generated from enum value: FIELD_METADATA_ATTRIBUTE = 40;
   */
  METADATA_ATTRIBUTE = 40,
}
// Retrieve enum metadata with: proto3.getEnumType(Field)
proto3.util.setEnumType(Field, "kuksa.val.v1.Field", [
  { no: 0, name: "FIELD_UNSPECIFIED" },
  { no: 1, name: "FIELD_PATH" },
  { no: 2, name: "FIELD_VALUE" },
  { no: 3, name: "FIELD_ACTUATOR_TARGET" },
  { no: 10, name: "FIELD_METADATA" },
  { no: 11, name: "FIELD_METADATA_DATA_TYPE" },
  { no: 12, name: "FIELD_METADATA_DESCRIPTION" },
  { no: 13, name: "FIELD_METADATA_ENTRY_TYPE" },
  { no: 14, name: "FIELD_METADATA_COMMENT" },
  { no: 15, name: "FIELD_METADATA_DEPRECATION" },
  { no: 16, name: "FIELD_METADATA_UNIT" },
  { no: 17, name: "FIELD_METADATA_VALUE_RESTRICTION" },
  { no: 20, name: "FIELD_METADATA_ACTUATOR" },
  { no: 30, name: "FIELD_METADATA_SENSOR" },
  { no: 40, name: "FIELD_METADATA_ATTRIBUTE" },
]);

/**
 * Describes a VSS entry
 * When requesting an entry, the amount of information returned can
 * be controlled by specifying either a `View` or a set of `Field`s.
 *
 * @generated from message kuksa.val.v1.DataEntry
 */
export class DataEntry extends Message<DataEntry> {
  /**
   * Defines the full VSS path of the entry.
   *
   * [field: FIELD_PATH]
   *
   * @generated from field: string path = 1;
   */
  path = "";

  /**
   * The value (datapoint)
   *
   * [field: FIELD_VALUE]
   *
   * @generated from field: kuksa.val.v1.Datapoint value = 2;
   */
  value?: Datapoint;

  /**
   * Actuator target (only used if the entry is an actuator)
   *
   * [field: FIELD_ACTUATOR_TARGET]
   *
   * @generated from field: kuksa.val.v1.Datapoint actuator_target = 3;
   */
  actuatorTarget?: Datapoint;

  /**
   * Metadata for this entry
   *
   * [field: FIELD_METADATA]
   *
   * @generated from field: kuksa.val.v1.Metadata metadata = 10;
   */
  metadata?: Metadata;

  constructor(data?: PartialMessage<DataEntry>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "kuksa.val.v1.DataEntry";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "path", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "value", kind: "message", T: Datapoint },
    { no: 3, name: "actuator_target", kind: "message", T: Datapoint },
    { no: 10, name: "metadata", kind: "message", T: Metadata },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): DataEntry {
    return new DataEntry().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): DataEntry {
    return new DataEntry().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): DataEntry {
    return new DataEntry().fromJsonString(jsonString, options);
  }

  static equals(a: DataEntry | PlainMessage<DataEntry> | undefined, b: DataEntry | PlainMessage<DataEntry> | undefined): boolean {
    return proto3.util.equals(DataEntry, a, b);
  }
}

/**
 * @generated from message kuksa.val.v1.Datapoint
 */
export class Datapoint extends Message<Datapoint> {
  /**
   * @generated from field: google.protobuf.Timestamp timestamp = 1;
   */
  timestamp?: Timestamp;

  /**
   * @generated from oneof kuksa.val.v1.Datapoint.value
   */
  value: {
    /**
     * @generated from field: string string = 11;
     */
    value: string;
    case: "string";
  } | {
    /**
     * @generated from field: bool bool = 12;
     */
    value: boolean;
    case: "bool";
  } | {
    /**
     * @generated from field: sint32 int32 = 13;
     */
    value: number;
    case: "int32";
  } | {
    /**
     * @generated from field: sint64 int64 = 14;
     */
    value: bigint;
    case: "int64";
  } | {
    /**
     * @generated from field: uint32 uint32 = 15;
     */
    value: number;
    case: "uint32";
  } | {
    /**
     * @generated from field: uint64 uint64 = 16;
     */
    value: bigint;
    case: "uint64";
  } | {
    /**
     * @generated from field: float float = 17;
     */
    value: number;
    case: "float";
  } | {
    /**
     * @generated from field: double double = 18;
     */
    value: number;
    case: "double";
  } | {
    /**
     * @generated from field: kuksa.val.v1.StringArray string_array = 21;
     */
    value: StringArray;
    case: "stringArray";
  } | {
    /**
     * @generated from field: kuksa.val.v1.BoolArray bool_array = 22;
     */
    value: BoolArray;
    case: "boolArray";
  } | {
    /**
     * @generated from field: kuksa.val.v1.Int32Array int32_array = 23;
     */
    value: Int32Array;
    case: "int32Array";
  } | {
    /**
     * @generated from field: kuksa.val.v1.Int64Array int64_array = 24;
     */
    value: Int64Array;
    case: "int64Array";
  } | {
    /**
     * @generated from field: kuksa.val.v1.Uint32Array uint32_array = 25;
     */
    value: Uint32Array;
    case: "uint32Array";
  } | {
    /**
     * @generated from field: kuksa.val.v1.Uint64Array uint64_array = 26;
     */
    value: Uint64Array;
    case: "uint64Array";
  } | {
    /**
     * @generated from field: kuksa.val.v1.FloatArray float_array = 27;
     */
    value: FloatArray;
    case: "floatArray";
  } | {
    /**
     * @generated from field: kuksa.val.v1.DoubleArray double_array = 28;
     */
    value: DoubleArray;
    case: "doubleArray";
  } | { case: undefined; value?: undefined } = { case: undefined };

  constructor(data?: PartialMessage<Datapoint>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "kuksa.val.v1.Datapoint";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "timestamp", kind: "message", T: Timestamp },
    { no: 11, name: "string", kind: "scalar", T: 9 /* ScalarType.STRING */, oneof: "value" },
    { no: 12, name: "bool", kind: "scalar", T: 8 /* ScalarType.BOOL */, oneof: "value" },
    { no: 13, name: "int32", kind: "scalar", T: 17 /* ScalarType.SINT32 */, oneof: "value" },
    { no: 14, name: "int64", kind: "scalar", T: 18 /* ScalarType.SINT64 */, oneof: "value" },
    { no: 15, name: "uint32", kind: "scalar", T: 13 /* ScalarType.UINT32 */, oneof: "value" },
    { no: 16, name: "uint64", kind: "scalar", T: 4 /* ScalarType.UINT64 */, oneof: "value" },
    { no: 17, name: "float", kind: "scalar", T: 2 /* ScalarType.FLOAT */, oneof: "value" },
    { no: 18, name: "double", kind: "scalar", T: 1 /* ScalarType.DOUBLE */, oneof: "value" },
    { no: 21, name: "string_array", kind: "message", T: StringArray, oneof: "value" },
    { no: 22, name: "bool_array", kind: "message", T: BoolArray, oneof: "value" },
    { no: 23, name: "int32_array", kind: "message", T: Int32Array, oneof: "value" },
    { no: 24, name: "int64_array", kind: "message", T: Int64Array, oneof: "value" },
    { no: 25, name: "uint32_array", kind: "message", T: Uint32Array, oneof: "value" },
    { no: 26, name: "uint64_array", kind: "message", T: Uint64Array, oneof: "value" },
    { no: 27, name: "float_array", kind: "message", T: FloatArray, oneof: "value" },
    { no: 28, name: "double_array", kind: "message", T: DoubleArray, oneof: "value" },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Datapoint {
    return new Datapoint().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Datapoint {
    return new Datapoint().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Datapoint {
    return new Datapoint().fromJsonString(jsonString, options);
  }

  static equals(a: Datapoint | PlainMessage<Datapoint> | undefined, b: Datapoint | PlainMessage<Datapoint> | undefined): boolean {
    return proto3.util.equals(Datapoint, a, b);
  }
}

/**
 * @generated from message kuksa.val.v1.Metadata
 */
export class Metadata extends Message<Metadata> {
  /**
   * Data type
   * The VSS data type of the entry (i.e. the value, min, max etc).
   *
   * NOTE: protobuf doesn't have int8, int16, uint8 or uint16 which means
   * that these values must be serialized as int32 and uint32 respectively.
   *
   * [field: FIELD_METADATA_DATA_TYPE]
   *
   * @generated from field: kuksa.val.v1.DataType data_type = 11;
   */
  dataType = DataType.UNSPECIFIED;

  /**
   * Entry type
   *
   * [field: FIELD_METADATA_ENTRY_TYPE]
   *
   * @generated from field: kuksa.val.v1.EntryType entry_type = 12;
   */
  entryType = EntryType.UNSPECIFIED;

  /**
   * Description
   * Describes the meaning and content of the entry.
   *
   * [field: FIELD_METADATA_DESCRIPTION]
   *
   * @generated from field: optional string description = 13;
   */
  description?: string;

  /**
   * Comment [optional]
   * A comment can be used to provide additional informal information
   * on a entry.
   *
   * [field: FIELD_METADATA_COMMENT]
   *
   * @generated from field: optional string comment = 14;
   */
  comment?: string;

  /**
   * Deprecation [optional]
   * Whether this entry is deprecated. Can contain recommendations of what
   * to use instead.
   *
   * [field: FIELD_METADATA_DEPRECATION]
   *
   * @generated from field: optional string deprecation = 15;
   */
  deprecation?: string;

  /**
   * Unit [optional]
   * The unit of measurement
   *
   * [field: FIELD_METADATA_UNIT]
   *
   * @generated from field: optional string unit = 16;
   */
  unit?: string;

  /**
   * Value restrictions [optional]
   * Restrict which values are allowed.
   * Only restrictions matching the DataType {datatype} above are valid.
   *
   * [field: FIELD_METADATA_VALUE_RESTRICTION]
   *
   * @generated from field: kuksa.val.v1.ValueRestriction value_restriction = 17;
   */
  valueRestriction?: ValueRestriction;

  /**
   * Entry type specific metadata
   *
   * @generated from oneof kuksa.val.v1.Metadata.entry_specific
   */
  entrySpecific: {
    /**
     * [field: FIELD_METADATA_ACTUATOR]
     *
     * @generated from field: kuksa.val.v1.Actuator actuator = 20;
     */
    value: Actuator;
    case: "actuator";
  } | {
    /**
     * [field: FIELD_METADATA_SENSOR]
     *
     * @generated from field: kuksa.val.v1.Sensor sensor = 30;
     */
    value: Sensor;
    case: "sensor";
  } | {
    /**
     * [field: FIELD_METADATA_ATTRIBUTE]
     *
     * @generated from field: kuksa.val.v1.Attribute attribute = 40;
     */
    value: Attribute;
    case: "attribute";
  } | { case: undefined; value?: undefined } = { case: undefined };

  constructor(data?: PartialMessage<Metadata>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "kuksa.val.v1.Metadata";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 11, name: "data_type", kind: "enum", T: proto3.getEnumType(DataType) },
    { no: 12, name: "entry_type", kind: "enum", T: proto3.getEnumType(EntryType) },
    { no: 13, name: "description", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 14, name: "comment", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 15, name: "deprecation", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 16, name: "unit", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 17, name: "value_restriction", kind: "message", T: ValueRestriction },
    { no: 20, name: "actuator", kind: "message", T: Actuator, oneof: "entry_specific" },
    { no: 30, name: "sensor", kind: "message", T: Sensor, oneof: "entry_specific" },
    { no: 40, name: "attribute", kind: "message", T: Attribute, oneof: "entry_specific" },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Metadata {
    return new Metadata().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Metadata {
    return new Metadata().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Metadata {
    return new Metadata().fromJsonString(jsonString, options);
  }

  static equals(a: Metadata | PlainMessage<Metadata> | undefined, b: Metadata | PlainMessage<Metadata> | undefined): boolean {
    return proto3.util.equals(Metadata, a, b);
  }
}

/**
 * /////////////////////
 * Actuator specific fields
 *
 * Nothing for now
 *
 * @generated from message kuksa.val.v1.Actuator
 */
export class Actuator extends Message<Actuator> {
  constructor(data?: PartialMessage<Actuator>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "kuksa.val.v1.Actuator";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Actuator {
    return new Actuator().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Actuator {
    return new Actuator().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Actuator {
    return new Actuator().fromJsonString(jsonString, options);
  }

  static equals(a: Actuator | PlainMessage<Actuator> | undefined, b: Actuator | PlainMessage<Actuator> | undefined): boolean {
    return proto3.util.equals(Actuator, a, b);
  }
}

/**
 * //////////////////////
 * Sensor specific
 *
 * Nothing for now
 *
 * @generated from message kuksa.val.v1.Sensor
 */
export class Sensor extends Message<Sensor> {
  constructor(data?: PartialMessage<Sensor>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "kuksa.val.v1.Sensor";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Sensor {
    return new Sensor().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Sensor {
    return new Sensor().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Sensor {
    return new Sensor().fromJsonString(jsonString, options);
  }

  static equals(a: Sensor | PlainMessage<Sensor> | undefined, b: Sensor | PlainMessage<Sensor> | undefined): boolean {
    return proto3.util.equals(Sensor, a, b);
  }
}

/**
 * //////////////////////
 * Attribute specific
 *
 * Nothing for now.
 *
 * @generated from message kuksa.val.v1.Attribute
 */
export class Attribute extends Message<Attribute> {
  constructor(data?: PartialMessage<Attribute>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "kuksa.val.v1.Attribute";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Attribute {
    return new Attribute().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Attribute {
    return new Attribute().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Attribute {
    return new Attribute().fromJsonString(jsonString, options);
  }

  static equals(a: Attribute | PlainMessage<Attribute> | undefined, b: Attribute | PlainMessage<Attribute> | undefined): boolean {
    return proto3.util.equals(Attribute, a, b);
  }
}

/**
 * Value restriction
 *
 * One ValueRestriction{type} for each type, since
 * they don't make sense unless the types match
 *
 *
 * @generated from message kuksa.val.v1.ValueRestriction
 */
export class ValueRestriction extends Message<ValueRestriction> {
  /**
   * @generated from oneof kuksa.val.v1.ValueRestriction.type
   */
  type: {
    /**
     * @generated from field: kuksa.val.v1.ValueRestrictionString string = 21;
     */
    value: ValueRestrictionString;
    case: "string";
  } | {
    /**
     * For signed VSS integers
     *
     * @generated from field: kuksa.val.v1.ValueRestrictionInt signed = 22;
     */
    value: ValueRestrictionInt;
    case: "signed";
  } | {
    /**
     * For unsigned VSS integers
     *
     * @generated from field: kuksa.val.v1.ValueRestrictionUint unsigned = 23;
     */
    value: ValueRestrictionUint;
    case: "unsigned";
  } | {
    /**
     * For floating point VSS values (float and double)
     *
     * @generated from field: kuksa.val.v1.ValueRestrictionFloat floating_point = 24;
     */
    value: ValueRestrictionFloat;
    case: "floatingPoint";
  } | { case: undefined; value?: undefined } = { case: undefined };

  constructor(data?: PartialMessage<ValueRestriction>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "kuksa.val.v1.ValueRestriction";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 21, name: "string", kind: "message", T: ValueRestrictionString, oneof: "type" },
    { no: 22, name: "signed", kind: "message", T: ValueRestrictionInt, oneof: "type" },
    { no: 23, name: "unsigned", kind: "message", T: ValueRestrictionUint, oneof: "type" },
    { no: 24, name: "floating_point", kind: "message", T: ValueRestrictionFloat, oneof: "type" },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ValueRestriction {
    return new ValueRestriction().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ValueRestriction {
    return new ValueRestriction().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ValueRestriction {
    return new ValueRestriction().fromJsonString(jsonString, options);
  }

  static equals(a: ValueRestriction | PlainMessage<ValueRestriction> | undefined, b: ValueRestriction | PlainMessage<ValueRestriction> | undefined): boolean {
    return proto3.util.equals(ValueRestriction, a, b);
  }
}

/**
 * @generated from message kuksa.val.v1.ValueRestrictionInt
 */
export class ValueRestrictionInt extends Message<ValueRestrictionInt> {
  /**
   * @generated from field: optional sint64 min = 1;
   */
  min?: bigint;

  /**
   * @generated from field: optional sint64 max = 2;
   */
  max?: bigint;

  /**
   * @generated from field: repeated sint64 allowed_values = 3;
   */
  allowedValues: bigint[] = [];

  constructor(data?: PartialMessage<ValueRestrictionInt>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "kuksa.val.v1.ValueRestrictionInt";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "min", kind: "scalar", T: 18 /* ScalarType.SINT64 */, opt: true },
    { no: 2, name: "max", kind: "scalar", T: 18 /* ScalarType.SINT64 */, opt: true },
    { no: 3, name: "allowed_values", kind: "scalar", T: 18 /* ScalarType.SINT64 */, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ValueRestrictionInt {
    return new ValueRestrictionInt().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ValueRestrictionInt {
    return new ValueRestrictionInt().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ValueRestrictionInt {
    return new ValueRestrictionInt().fromJsonString(jsonString, options);
  }

  static equals(a: ValueRestrictionInt | PlainMessage<ValueRestrictionInt> | undefined, b: ValueRestrictionInt | PlainMessage<ValueRestrictionInt> | undefined): boolean {
    return proto3.util.equals(ValueRestrictionInt, a, b);
  }
}

/**
 * @generated from message kuksa.val.v1.ValueRestrictionUint
 */
export class ValueRestrictionUint extends Message<ValueRestrictionUint> {
  /**
   * @generated from field: optional uint64 min = 1;
   */
  min?: bigint;

  /**
   * @generated from field: optional uint64 max = 2;
   */
  max?: bigint;

  /**
   * @generated from field: repeated uint64 allowed_values = 3;
   */
  allowedValues: bigint[] = [];

  constructor(data?: PartialMessage<ValueRestrictionUint>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "kuksa.val.v1.ValueRestrictionUint";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "min", kind: "scalar", T: 4 /* ScalarType.UINT64 */, opt: true },
    { no: 2, name: "max", kind: "scalar", T: 4 /* ScalarType.UINT64 */, opt: true },
    { no: 3, name: "allowed_values", kind: "scalar", T: 4 /* ScalarType.UINT64 */, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ValueRestrictionUint {
    return new ValueRestrictionUint().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ValueRestrictionUint {
    return new ValueRestrictionUint().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ValueRestrictionUint {
    return new ValueRestrictionUint().fromJsonString(jsonString, options);
  }

  static equals(a: ValueRestrictionUint | PlainMessage<ValueRestrictionUint> | undefined, b: ValueRestrictionUint | PlainMessage<ValueRestrictionUint> | undefined): boolean {
    return proto3.util.equals(ValueRestrictionUint, a, b);
  }
}

/**
 * @generated from message kuksa.val.v1.ValueRestrictionFloat
 */
export class ValueRestrictionFloat extends Message<ValueRestrictionFloat> {
  /**
   * @generated from field: optional double min = 1;
   */
  min?: number;

  /**
   * @generated from field: optional double max = 2;
   */
  max?: number;

  /**
   * allowed for doubles/floats not recommended
   *
   * @generated from field: repeated double allowed_values = 3;
   */
  allowedValues: number[] = [];

  constructor(data?: PartialMessage<ValueRestrictionFloat>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "kuksa.val.v1.ValueRestrictionFloat";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "min", kind: "scalar", T: 1 /* ScalarType.DOUBLE */, opt: true },
    { no: 2, name: "max", kind: "scalar", T: 1 /* ScalarType.DOUBLE */, opt: true },
    { no: 3, name: "allowed_values", kind: "scalar", T: 1 /* ScalarType.DOUBLE */, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ValueRestrictionFloat {
    return new ValueRestrictionFloat().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ValueRestrictionFloat {
    return new ValueRestrictionFloat().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ValueRestrictionFloat {
    return new ValueRestrictionFloat().fromJsonString(jsonString, options);
  }

  static equals(a: ValueRestrictionFloat | PlainMessage<ValueRestrictionFloat> | undefined, b: ValueRestrictionFloat | PlainMessage<ValueRestrictionFloat> | undefined): boolean {
    return proto3.util.equals(ValueRestrictionFloat, a, b);
  }
}

/**
 * min, max doesn't make much sense for a string
 *
 * @generated from message kuksa.val.v1.ValueRestrictionString
 */
export class ValueRestrictionString extends Message<ValueRestrictionString> {
  /**
   * @generated from field: repeated string allowed_values = 3;
   */
  allowedValues: string[] = [];

  constructor(data?: PartialMessage<ValueRestrictionString>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "kuksa.val.v1.ValueRestrictionString";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 3, name: "allowed_values", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ValueRestrictionString {
    return new ValueRestrictionString().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ValueRestrictionString {
    return new ValueRestrictionString().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ValueRestrictionString {
    return new ValueRestrictionString().fromJsonString(jsonString, options);
  }

  static equals(a: ValueRestrictionString | PlainMessage<ValueRestrictionString> | undefined, b: ValueRestrictionString | PlainMessage<ValueRestrictionString> | undefined): boolean {
    return proto3.util.equals(ValueRestrictionString, a, b);
  }
}

/**
 * Error response shall be an HTTP-like code.
 * Should follow https://www.w3.org/TR/viss2-transport/#status-codes.
 *
 * @generated from message kuksa.val.v1.Error
 */
export class Error extends Message<Error> {
  /**
   * @generated from field: uint32 code = 1;
   */
  code = 0;

  /**
   * @generated from field: string reason = 2;
   */
  reason = "";

  /**
   * @generated from field: string message = 3;
   */
  message = "";

  constructor(data?: PartialMessage<Error>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "kuksa.val.v1.Error";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "code", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
    { no: 2, name: "reason", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "message", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Error {
    return new Error().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Error {
    return new Error().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Error {
    return new Error().fromJsonString(jsonString, options);
  }

  static equals(a: Error | PlainMessage<Error> | undefined, b: Error | PlainMessage<Error> | undefined): boolean {
    return proto3.util.equals(Error, a, b);
  }
}

/**
 * Used in get/set requests to report errors for specific entries
 *
 * @generated from message kuksa.val.v1.DataEntryError
 */
export class DataEntryError extends Message<DataEntryError> {
  /**
   * vss path
   *
   * @generated from field: string path = 1;
   */
  path = "";

  /**
   * @generated from field: kuksa.val.v1.Error error = 2;
   */
  error?: Error;

  constructor(data?: PartialMessage<DataEntryError>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "kuksa.val.v1.DataEntryError";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "path", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "error", kind: "message", T: Error },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): DataEntryError {
    return new DataEntryError().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): DataEntryError {
    return new DataEntryError().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): DataEntryError {
    return new DataEntryError().fromJsonString(jsonString, options);
  }

  static equals(a: DataEntryError | PlainMessage<DataEntryError> | undefined, b: DataEntryError | PlainMessage<DataEntryError> | undefined): boolean {
    return proto3.util.equals(DataEntryError, a, b);
  }
}

/**
 * @generated from message kuksa.val.v1.StringArray
 */
export class StringArray extends Message<StringArray> {
  /**
   * @generated from field: repeated string values = 1;
   */
  values: string[] = [];

  constructor(data?: PartialMessage<StringArray>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "kuksa.val.v1.StringArray";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "values", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): StringArray {
    return new StringArray().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): StringArray {
    return new StringArray().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): StringArray {
    return new StringArray().fromJsonString(jsonString, options);
  }

  static equals(a: StringArray | PlainMessage<StringArray> | undefined, b: StringArray | PlainMessage<StringArray> | undefined): boolean {
    return proto3.util.equals(StringArray, a, b);
  }
}

/**
 * @generated from message kuksa.val.v1.BoolArray
 */
export class BoolArray extends Message<BoolArray> {
  /**
   * @generated from field: repeated bool values = 1;
   */
  values: boolean[] = [];

  constructor(data?: PartialMessage<BoolArray>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "kuksa.val.v1.BoolArray";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "values", kind: "scalar", T: 8 /* ScalarType.BOOL */, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): BoolArray {
    return new BoolArray().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): BoolArray {
    return new BoolArray().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): BoolArray {
    return new BoolArray().fromJsonString(jsonString, options);
  }

  static equals(a: BoolArray | PlainMessage<BoolArray> | undefined, b: BoolArray | PlainMessage<BoolArray> | undefined): boolean {
    return proto3.util.equals(BoolArray, a, b);
  }
}

/**
 * @generated from message kuksa.val.v1.Int32Array
 */
export class Int32Array extends Message<Int32Array> {
  /**
   * @generated from field: repeated sint32 values = 1;
   */
  values: number[] = [];

  constructor(data?: PartialMessage<Int32Array>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "kuksa.val.v1.Int32Array";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "values", kind: "scalar", T: 17 /* ScalarType.SINT32 */, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Int32Array {
    return new Int32Array().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Int32Array {
    return new Int32Array().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Int32Array {
    return new Int32Array().fromJsonString(jsonString, options);
  }

  static equals(a: Int32Array | PlainMessage<Int32Array> | undefined, b: Int32Array | PlainMessage<Int32Array> | undefined): boolean {
    return proto3.util.equals(Int32Array, a, b);
  }
}

/**
 * @generated from message kuksa.val.v1.Int64Array
 */
export class Int64Array extends Message<Int64Array> {
  /**
   * @generated from field: repeated sint64 values = 1;
   */
  values: bigint[] = [];

  constructor(data?: PartialMessage<Int64Array>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "kuksa.val.v1.Int64Array";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "values", kind: "scalar", T: 18 /* ScalarType.SINT64 */, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Int64Array {
    return new Int64Array().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Int64Array {
    return new Int64Array().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Int64Array {
    return new Int64Array().fromJsonString(jsonString, options);
  }

  static equals(a: Int64Array | PlainMessage<Int64Array> | undefined, b: Int64Array | PlainMessage<Int64Array> | undefined): boolean {
    return proto3.util.equals(Int64Array, a, b);
  }
}

/**
 * @generated from message kuksa.val.v1.Uint32Array
 */
export class Uint32Array extends Message<Uint32Array> {
  /**
   * @generated from field: repeated uint32 values = 1;
   */
  values: number[] = [];

  constructor(data?: PartialMessage<Uint32Array>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "kuksa.val.v1.Uint32Array";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "values", kind: "scalar", T: 13 /* ScalarType.UINT32 */, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Uint32Array {
    return new Uint32Array().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Uint32Array {
    return new Uint32Array().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Uint32Array {
    return new Uint32Array().fromJsonString(jsonString, options);
  }

  static equals(a: Uint32Array | PlainMessage<Uint32Array> | undefined, b: Uint32Array | PlainMessage<Uint32Array> | undefined): boolean {
    return proto3.util.equals(Uint32Array, a, b);
  }
}

/**
 * @generated from message kuksa.val.v1.Uint64Array
 */
export class Uint64Array extends Message<Uint64Array> {
  /**
   * @generated from field: repeated uint64 values = 1;
   */
  values: bigint[] = [];

  constructor(data?: PartialMessage<Uint64Array>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "kuksa.val.v1.Uint64Array";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "values", kind: "scalar", T: 4 /* ScalarType.UINT64 */, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Uint64Array {
    return new Uint64Array().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Uint64Array {
    return new Uint64Array().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Uint64Array {
    return new Uint64Array().fromJsonString(jsonString, options);
  }

  static equals(a: Uint64Array | PlainMessage<Uint64Array> | undefined, b: Uint64Array | PlainMessage<Uint64Array> | undefined): boolean {
    return proto3.util.equals(Uint64Array, a, b);
  }
}

/**
 * @generated from message kuksa.val.v1.FloatArray
 */
export class FloatArray extends Message<FloatArray> {
  /**
   * @generated from field: repeated float values = 1;
   */
  values: number[] = [];

  constructor(data?: PartialMessage<FloatArray>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "kuksa.val.v1.FloatArray";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "values", kind: "scalar", T: 2 /* ScalarType.FLOAT */, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): FloatArray {
    return new FloatArray().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): FloatArray {
    return new FloatArray().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): FloatArray {
    return new FloatArray().fromJsonString(jsonString, options);
  }

  static equals(a: FloatArray | PlainMessage<FloatArray> | undefined, b: FloatArray | PlainMessage<FloatArray> | undefined): boolean {
    return proto3.util.equals(FloatArray, a, b);
  }
}

/**
 * @generated from message kuksa.val.v1.DoubleArray
 */
export class DoubleArray extends Message<DoubleArray> {
  /**
   * @generated from field: repeated double values = 1;
   */
  values: number[] = [];

  constructor(data?: PartialMessage<DoubleArray>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "kuksa.val.v1.DoubleArray";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "values", kind: "scalar", T: 1 /* ScalarType.DOUBLE */, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): DoubleArray {
    return new DoubleArray().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): DoubleArray {
    return new DoubleArray().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): DoubleArray {
    return new DoubleArray().fromJsonString(jsonString, options);
  }

  static equals(a: DoubleArray | PlainMessage<DoubleArray> | undefined, b: DoubleArray | PlainMessage<DoubleArray> | undefined): boolean {
    return proto3.util.equals(DoubleArray, a, b);
  }
}

