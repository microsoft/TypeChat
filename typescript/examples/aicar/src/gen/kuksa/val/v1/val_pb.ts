//*******************************************************************************
// Copyright (c) 2022 Contributors to the Eclipse Foundation
//
// See the NOTICE file(s) distributed with this work for additional
// information regarding copyright ownership.
//
// This program and the accompanying materials are made available under the
// terms of the Apache License 2.0 which is available at
// http://www.apache.org/licenses/LICENSE-2.0
//
// SPDX-License-Identifier: Apache-2.0
//******************************************************************************

// @generated by protoc-gen-es v1.10.0 with parameter "target=ts"
// @generated from file kuksa/val/v1/val.proto (package kuksa.val.v1, syntax proto3)
/* eslint-disable */
// @ts-nocheck

import type { BinaryReadOptions, FieldList, JsonReadOptions, JsonValue, PartialMessage, PlainMessage } from "@bufbuild/protobuf";
import { Message, proto3 } from "@bufbuild/protobuf";
import { DataEntry, DataEntryError, Error, Field, View } from "./types_pb.js";

/**
 * Define which data we want
 *
 * @generated from message kuksa.val.v1.EntryRequest
 */
export class EntryRequest extends Message<EntryRequest> {
  /**
   * @generated from field: string path = 1;
   */
  path = "";

  /**
   * @generated from field: kuksa.val.v1.View view = 2;
   */
  view = View.UNSPECIFIED;

  /**
   * @generated from field: repeated kuksa.val.v1.Field fields = 3;
   */
  fields: Field[] = [];

  constructor(data?: PartialMessage<EntryRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "kuksa.val.v1.EntryRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "path", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "view", kind: "enum", T: proto3.getEnumType(View) },
    { no: 3, name: "fields", kind: "enum", T: proto3.getEnumType(Field), repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): EntryRequest {
    return new EntryRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): EntryRequest {
    return new EntryRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): EntryRequest {
    return new EntryRequest().fromJsonString(jsonString, options);
  }

  static equals(a: EntryRequest | PlainMessage<EntryRequest> | undefined, b: EntryRequest | PlainMessage<EntryRequest> | undefined): boolean {
    return proto3.util.equals(EntryRequest, a, b);
  }
}

/**
 * Request a set of entries.
 *
 * @generated from message kuksa.val.v1.GetRequest
 */
export class GetRequest extends Message<GetRequest> {
  /**
   * @generated from field: repeated kuksa.val.v1.EntryRequest entries = 1;
   */
  entries: EntryRequest[] = [];

  constructor(data?: PartialMessage<GetRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "kuksa.val.v1.GetRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "entries", kind: "message", T: EntryRequest, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetRequest {
    return new GetRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetRequest {
    return new GetRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetRequest {
    return new GetRequest().fromJsonString(jsonString, options);
  }

  static equals(a: GetRequest | PlainMessage<GetRequest> | undefined, b: GetRequest | PlainMessage<GetRequest> | undefined): boolean {
    return proto3.util.equals(GetRequest, a, b);
  }
}

/**
 * Global errors are specified in `error`.
 * Errors for individual entries are specified in `errors`.
 *
 * @generated from message kuksa.val.v1.GetResponse
 */
export class GetResponse extends Message<GetResponse> {
  /**
   * @generated from field: repeated kuksa.val.v1.DataEntry entries = 1;
   */
  entries: DataEntry[] = [];

  /**
   * @generated from field: repeated kuksa.val.v1.DataEntryError errors = 2;
   */
  errors: DataEntryError[] = [];

  /**
   * @generated from field: kuksa.val.v1.Error error = 3;
   */
  error?: Error;

  constructor(data?: PartialMessage<GetResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "kuksa.val.v1.GetResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "entries", kind: "message", T: DataEntry, repeated: true },
    { no: 2, name: "errors", kind: "message", T: DataEntryError, repeated: true },
    { no: 3, name: "error", kind: "message", T: Error },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetResponse {
    return new GetResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetResponse {
    return new GetResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetResponse {
    return new GetResponse().fromJsonString(jsonString, options);
  }

  static equals(a: GetResponse | PlainMessage<GetResponse> | undefined, b: GetResponse | PlainMessage<GetResponse> | undefined): boolean {
    return proto3.util.equals(GetResponse, a, b);
  }
}

/**
 * Define the data we want to set
 *
 * @generated from message kuksa.val.v1.EntryUpdate
 */
export class EntryUpdate extends Message<EntryUpdate> {
  /**
   * @generated from field: kuksa.val.v1.DataEntry entry = 1;
   */
  entry?: DataEntry;

  /**
   * @generated from field: repeated kuksa.val.v1.Field fields = 2;
   */
  fields: Field[] = [];

  constructor(data?: PartialMessage<EntryUpdate>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "kuksa.val.v1.EntryUpdate";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "entry", kind: "message", T: DataEntry },
    { no: 2, name: "fields", kind: "enum", T: proto3.getEnumType(Field), repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): EntryUpdate {
    return new EntryUpdate().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): EntryUpdate {
    return new EntryUpdate().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): EntryUpdate {
    return new EntryUpdate().fromJsonString(jsonString, options);
  }

  static equals(a: EntryUpdate | PlainMessage<EntryUpdate> | undefined, b: EntryUpdate | PlainMessage<EntryUpdate> | undefined): boolean {
    return proto3.util.equals(EntryUpdate, a, b);
  }
}

/**
 * A list of entries to be updated
 *
 * @generated from message kuksa.val.v1.SetRequest
 */
export class SetRequest extends Message<SetRequest> {
  /**
   * @generated from field: repeated kuksa.val.v1.EntryUpdate updates = 1;
   */
  updates: EntryUpdate[] = [];

  constructor(data?: PartialMessage<SetRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "kuksa.val.v1.SetRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "updates", kind: "message", T: EntryUpdate, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SetRequest {
    return new SetRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SetRequest {
    return new SetRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SetRequest {
    return new SetRequest().fromJsonString(jsonString, options);
  }

  static equals(a: SetRequest | PlainMessage<SetRequest> | undefined, b: SetRequest | PlainMessage<SetRequest> | undefined): boolean {
    return proto3.util.equals(SetRequest, a, b);
  }
}

/**
 * Global errors are specified in `error`.
 * Errors for individual entries are specified in `errors`.
 *
 * @generated from message kuksa.val.v1.SetResponse
 */
export class SetResponse extends Message<SetResponse> {
  /**
   * @generated from field: kuksa.val.v1.Error error = 1;
   */
  error?: Error;

  /**
   * @generated from field: repeated kuksa.val.v1.DataEntryError errors = 2;
   */
  errors: DataEntryError[] = [];

  constructor(data?: PartialMessage<SetResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "kuksa.val.v1.SetResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "error", kind: "message", T: Error },
    { no: 2, name: "errors", kind: "message", T: DataEntryError, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SetResponse {
    return new SetResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SetResponse {
    return new SetResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SetResponse {
    return new SetResponse().fromJsonString(jsonString, options);
  }

  static equals(a: SetResponse | PlainMessage<SetResponse> | undefined, b: SetResponse | PlainMessage<SetResponse> | undefined): boolean {
    return proto3.util.equals(SetResponse, a, b);
  }
}

/**
 * @generated from message kuksa.val.v1.StreamedUpdateRequest
 */
export class StreamedUpdateRequest extends Message<StreamedUpdateRequest> {
  /**
   * @generated from field: repeated kuksa.val.v1.EntryUpdate updates = 1;
   */
  updates: EntryUpdate[] = [];

  constructor(data?: PartialMessage<StreamedUpdateRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "kuksa.val.v1.StreamedUpdateRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "updates", kind: "message", T: EntryUpdate, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): StreamedUpdateRequest {
    return new StreamedUpdateRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): StreamedUpdateRequest {
    return new StreamedUpdateRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): StreamedUpdateRequest {
    return new StreamedUpdateRequest().fromJsonString(jsonString, options);
  }

  static equals(a: StreamedUpdateRequest | PlainMessage<StreamedUpdateRequest> | undefined, b: StreamedUpdateRequest | PlainMessage<StreamedUpdateRequest> | undefined): boolean {
    return proto3.util.equals(StreamedUpdateRequest, a, b);
  }
}

/**
 * @generated from message kuksa.val.v1.StreamedUpdateResponse
 */
export class StreamedUpdateResponse extends Message<StreamedUpdateResponse> {
  /**
   * @generated from field: kuksa.val.v1.Error error = 1;
   */
  error?: Error;

  /**
   * @generated from field: repeated kuksa.val.v1.DataEntryError errors = 2;
   */
  errors: DataEntryError[] = [];

  constructor(data?: PartialMessage<StreamedUpdateResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "kuksa.val.v1.StreamedUpdateResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "error", kind: "message", T: Error },
    { no: 2, name: "errors", kind: "message", T: DataEntryError, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): StreamedUpdateResponse {
    return new StreamedUpdateResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): StreamedUpdateResponse {
    return new StreamedUpdateResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): StreamedUpdateResponse {
    return new StreamedUpdateResponse().fromJsonString(jsonString, options);
  }

  static equals(a: StreamedUpdateResponse | PlainMessage<StreamedUpdateResponse> | undefined, b: StreamedUpdateResponse | PlainMessage<StreamedUpdateResponse> | undefined): boolean {
    return proto3.util.equals(StreamedUpdateResponse, a, b);
  }
}

/**
 * Define what to subscribe to
 *
 * @generated from message kuksa.val.v1.SubscribeEntry
 */
export class SubscribeEntry extends Message<SubscribeEntry> {
  /**
   * @generated from field: string path = 1;
   */
  path = "";

  /**
   * @generated from field: kuksa.val.v1.View view = 2;
   */
  view = View.UNSPECIFIED;

  /**
   * @generated from field: repeated kuksa.val.v1.Field fields = 3;
   */
  fields: Field[] = [];

  constructor(data?: PartialMessage<SubscribeEntry>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "kuksa.val.v1.SubscribeEntry";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "path", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "view", kind: "enum", T: proto3.getEnumType(View) },
    { no: 3, name: "fields", kind: "enum", T: proto3.getEnumType(Field), repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SubscribeEntry {
    return new SubscribeEntry().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SubscribeEntry {
    return new SubscribeEntry().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SubscribeEntry {
    return new SubscribeEntry().fromJsonString(jsonString, options);
  }

  static equals(a: SubscribeEntry | PlainMessage<SubscribeEntry> | undefined, b: SubscribeEntry | PlainMessage<SubscribeEntry> | undefined): boolean {
    return proto3.util.equals(SubscribeEntry, a, b);
  }
}

/**
 * Subscribe to changes in datapoints.
 *
 * @generated from message kuksa.val.v1.SubscribeRequest
 */
export class SubscribeRequest extends Message<SubscribeRequest> {
  /**
   * @generated from field: repeated kuksa.val.v1.SubscribeEntry entries = 1;
   */
  entries: SubscribeEntry[] = [];

  constructor(data?: PartialMessage<SubscribeRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "kuksa.val.v1.SubscribeRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "entries", kind: "message", T: SubscribeEntry, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SubscribeRequest {
    return new SubscribeRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SubscribeRequest {
    return new SubscribeRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SubscribeRequest {
    return new SubscribeRequest().fromJsonString(jsonString, options);
  }

  static equals(a: SubscribeRequest | PlainMessage<SubscribeRequest> | undefined, b: SubscribeRequest | PlainMessage<SubscribeRequest> | undefined): boolean {
    return proto3.util.equals(SubscribeRequest, a, b);
  }
}

/**
 * A subscription response
 *
 * @generated from message kuksa.val.v1.SubscribeResponse
 */
export class SubscribeResponse extends Message<SubscribeResponse> {
  /**
   * @generated from field: repeated kuksa.val.v1.EntryUpdate updates = 1;
   */
  updates: EntryUpdate[] = [];

  constructor(data?: PartialMessage<SubscribeResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "kuksa.val.v1.SubscribeResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "updates", kind: "message", T: EntryUpdate, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SubscribeResponse {
    return new SubscribeResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SubscribeResponse {
    return new SubscribeResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SubscribeResponse {
    return new SubscribeResponse().fromJsonString(jsonString, options);
  }

  static equals(a: SubscribeResponse | PlainMessage<SubscribeResponse> | undefined, b: SubscribeResponse | PlainMessage<SubscribeResponse> | undefined): boolean {
    return proto3.util.equals(SubscribeResponse, a, b);
  }
}

/**
 * Nothing yet
 *
 * @generated from message kuksa.val.v1.GetServerInfoRequest
 */
export class GetServerInfoRequest extends Message<GetServerInfoRequest> {
  constructor(data?: PartialMessage<GetServerInfoRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "kuksa.val.v1.GetServerInfoRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetServerInfoRequest {
    return new GetServerInfoRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetServerInfoRequest {
    return new GetServerInfoRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetServerInfoRequest {
    return new GetServerInfoRequest().fromJsonString(jsonString, options);
  }

  static equals(a: GetServerInfoRequest | PlainMessage<GetServerInfoRequest> | undefined, b: GetServerInfoRequest | PlainMessage<GetServerInfoRequest> | undefined): boolean {
    return proto3.util.equals(GetServerInfoRequest, a, b);
  }
}

/**
 * @generated from message kuksa.val.v1.GetServerInfoResponse
 */
export class GetServerInfoResponse extends Message<GetServerInfoResponse> {
  /**
   * @generated from field: string name = 1;
   */
  name = "";

  /**
   * @generated from field: string version = 2;
   */
  version = "";

  constructor(data?: PartialMessage<GetServerInfoResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "kuksa.val.v1.GetServerInfoResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "version", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetServerInfoResponse {
    return new GetServerInfoResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetServerInfoResponse {
    return new GetServerInfoResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetServerInfoResponse {
    return new GetServerInfoResponse().fromJsonString(jsonString, options);
  }

  static equals(a: GetServerInfoResponse | PlainMessage<GetServerInfoResponse> | undefined, b: GetServerInfoResponse | PlainMessage<GetServerInfoResponse> | undefined): boolean {
    return proto3.util.equals(GetServerInfoResponse, a, b);
  }
}

