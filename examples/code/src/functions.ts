/**
 * This is an experiment of using the TypeChat pattern to generate, validate, and execute simple JavaScript
 * functions based on combining user requests and a TypeScript schema. The permitted JavaScript subset is restricted to:
 * 
 * - No global variables or functions are accessible. The function can only access the parameters that were passed to it.
 * - Strings and arrays have a limited set of methods available (none of which mutate the object).
 * - Statements are restricted to expression statements, let and const declaration statements, if statements, and return
 *   statements. Other statements, such as for, while, do, switch, try, and throw, are not permitted, nor are function and
 *   class declaration statements.
 * - Call expressions must be of the form obj.method(arg1, arg2, ...). Calls to computed function values are not permitted.
 * - Arrow functions are permitted only as arguments to method calls. Arrow functions cannot be captured in local variables,
 *   objects, or arrays.
 * - Object literals may only include property assignments. Methods and get and set property accessors are not permitted.
 * - function, class, new, and await expressions are not permitted.
 * 
 * The subset specifically excludes looping constructs and recursive functions for which termination can't be assured. While
 * the subset attempts to reduce vulnerabilities, the executable function returned by getFunction() makes no guarantees
 * regarding code injection, spoofing, and so forth. Caveat emptor.
 */

import * as ts from "typescript";
import { TypeChatLanguageModel, Result, success, error } from "typechat";

const libText = `interface Array<T> {
    length: number;
    [n: number]: T;
    concat(...items: T[]): T[];
    join(separator?: string): string;
    slice(start?: number, end?: number): T[];
    indexOf(searchElement: T, fromIndex?: number): number;
    lastIndexOf(searchElement: T, fromIndex?: number): number;
    every(predicate: (value: T, index: number) => unknown): boolean;
    some(predicate: (value: T, index: number) => unknown): boolean;
    forEach(cb: (value: T, index: number) => void): void;
    map<U>(cb: (value: T, index: number) => U): U[];
    filter(predicate: (value: T, index: number) => unknown): T[];
}
interface String {
    readonly length: number;
    indexOf(searchString: string, position?: number): number;
    lastIndexOf(searchString: string, position?: number): number;
    search(regexp: string | RegExp): number;
    slice(start?: number, end?: number): string;
    split(separator: string | RegExp, limit?: number): string[];
    substring(start: number, end?: number): string;
    substr(from: number, length?: number): string;
    toLowerCase(): string;
    toUpperCase(): string;
    trim(): string;
    startsWith(searchString: string, position?: number): boolean;
    endsWith(searchString: string, endPosition?: number): boolean;
    includes(searchString: string, position?: number): boolean;
    repeat(count: number): string;
}
interface Object { toString(): string }
interface Function { prototype: unknown }
interface CallableFunction extends Function {}
interface NewableFunction extends Function {}
interface Boolean { valueOf(): boolean }
interface Number { valueOf(): number }
interface RegExp { test(string: string): boolean }`;

/**
 * An object that can translate natural language requests into JavaScript functions.
 */
export interface FunctionTranslator<T extends Function> {
    /**
     * The associated `TypeChatLanguageModel`.
     */
    model: TypeChatLanguageModel;
    /**
     * The associated `FunctionValidator<T>`.
     */
    validator: FunctionValidator<T>;
    /**
     * A boolean indicating whether to attempt repairing functions that fail to validate. The default is `true`,
     * but an application can set the property to `false` to disable repair attempts.
     */
    attemptRepair:  boolean;
    /**
     * Creates an AI language model prompt from the given request. This function is called by `translate`
     * to obtain the prompt. An application can assign a new function to provide a different prompt.
     * @param request The natural language request.
     * @returns A prompt that combines the request with the schema and type name of the underlying validator.
     */
    createRequestPrompt(request: string): string;
    /**
     * Creates a repair prompt to append to an original prompt/response in order to repair a function that
     * failed to validate. This function is called by `translate` when `attemptRepair` is true and the
     * function generated by the original prompt failed to validate. An application can assign a new function
     * to provide a different repair prompt.
     * @param validationError The error message returned by the validator.
     * @returns A repair prompt constructed from the error message.
     */
    createRepairPrompt(validationError: string): string;
    /**
     * Translates a natural language request into an object of type `ValidatedFunction<T>`. If the function
     * generated by the language model fails to validate and the `attemptRepair` property is `true`, a second
     * attempt to translate the request will be made. The prompt for the second attempt will include the
     * diagnostics produced for the first attempt. This often helps produce a valid result.
     * @param request The natural language request.
     * @returns A promise for the resulting object.
     */
    translate(request: string): Promise<Result<ValidatedFunction<T>>>;
}

/**
 * Represents an object that can validate and execute a simple subset of JavaScript functions. Validation is
 * performed by an in-memory instance of the TypeScript compiler. The specified type argument `T` must be the
 * same type as `typeName` in the given `schema`.
 */
export interface FunctionValidator<T extends Function> {
    /**
     * A string containing TypeScript source code for the validation schema.
     */
    schema: string;
    /**
     * The name of the target function type in the schema.
     */
    typeName: string;
    /**
     * An array of strings containing the names of the function's parameters.
     */
    parameterNames: string[];
    /**
     * Parses and validates the given JavaScript function body according to the associated TypeScript schema. Returns a
     * `Success<ValidatedFunction<T>>` object containing a runnable function if validation was successful. Otherwise, returns
     * an `Error` object with a `message` property that contains the TypeScript compiler diagnostics.
     * @param programText The function body of the JavaScript function to validate.
     * @returns A validated function or the TypeScript compiler diagnostic messages.
     */
    validate(functionBodyText: string): Result<ValidatedFunction<T>>;
}

/**
 * Represents a validated subset JavaScript function.
 */
export interface ValidatedFunction<T extends Function> {
    /**
     * The function body.
     */
    functionBodyText: string;
    /**
     * The parsed and validated statements of the function body.
     */
    block: ts.Block;
    /**
     * Returns a callable function created from the validated function body.
     */
    getFunction(): T;
}

/**
 * Creates an object that can translate natural language requests into JavaScript functions of the given type.
 * The specified type argument `T` must be the same type as `typeName` in the given `schema`. The function
 * creates a `FunctionValidator<T>` and stores it in the `validator` property of the returned instance.
 * @param model The language model to use for translating requests.
 * @param schema A string containing the TypeScript source code for the function schema.
 * @param typeName The name of the target function type in the schema.
 * @param parameterNames The names to use for the parameters of the generated function.
 * @returns A `TypeChatFunctionTranslator<T>` instance.
 */
export function createFunctionTranslator<T extends Function>(model: TypeChatLanguageModel, schema: string, typeName: string, parameterNames: string[]): FunctionTranslator<T> {
    const validator = createFunctionValidator<T>(schema, typeName, parameterNames);
    const typeChat: FunctionTranslator<T> = {
        model,
        validator,
        attemptRepair: true,
        createRequestPrompt,
        createRepairPrompt,
        translate
    };
    return typeChat;

    function createRequestPrompt(request: string) {
        return `You are a service that translates user requests into JavaScript functions according to the following TypeScript definitions:\n` +
            `\`\`\`\n${validator.schema}\`\`\`\n` +
            `The following is a user request:\n` +
            `"""\n${request}\n"""\n` +
            `Respond with a JavaScript function that satisfies the user request, similar to the following:\n` +
            `\`\`\`\nconst func: ${typeName} = (${parameterNames.join(", ")}) => {\n` +
            `    // Code to handle request\n` +
            `}\n\`\`\`\n` +
            `Prefer const for variable declarations. Never use var, for, while, do, switch, and try statements. Only output the JavaScript code, no comments.\n`;
    }

    function createRepairPrompt(validationError: string) {
        return `The function is invalid for the following reason:\n` +
            `${validationError}\n` +
            `The following is a revised function:\n`;
    }

    async function translate(request: string) {
        let prompt = typeChat.createRequestPrompt(request);
        let attemptRepair = typeChat.attemptRepair;
        while (true) {
            const response = await model.complete(prompt);
            if (!response.success) {
                return response;
            }
            const responseText = response.data;
            const startIndex = responseText.indexOf("{");
            const endIndex = responseText.lastIndexOf("}");
            if (!(startIndex >= 0 && endIndex > startIndex)) {
                return error(`Response is not a JavaScript function:\n${responseText}`);
            }
            const functionBodyText = responseText.slice(startIndex, endIndex + 1);
            const validation = validator.validate(functionBodyText);
            if (validation.success) {
                return validation;
            }
            if (!attemptRepair) {
                return error(`Function validation failed: ${validation.message}\n(${parameterNames.join(", ")}) => ${functionBodyText}`);
            }
            prompt += `${responseText}\n${typeChat.createRepairPrompt(validation.message)}`;
            attemptRepair = false;
        }
    }
}

/**
 * Returns a JavaScript subset program validator for a given TypeScript schema. Validation is performed by an in-memory
 * instance of the TypeScript compiler.
 * @param schema A string containing the JavaScript source code for the schema.
 * @param typeName The names of top-level exported objects in the schema.
 * @returns A `TypeChatProgramValidator` instance.
 */
export function createFunctionValidator<T extends Function>(schema: string, typeName: string, parameterNames: string[]): FunctionValidator<T> {
    const options = {
        ...ts.getDefaultCompilerOptions(),
        strict: true,
        skipLibCheck: true,
        noLib: true,
        types: []
    };
    const rootProgram = createProgramFromText("");
    const validator: FunctionValidator<T> = {
        schema,
        typeName,
        parameterNames,
        validate
    };
    return validator;

    function validate(functionBodyText: string) {
        const program = createProgramFromText(functionBodyText, rootProgram);
        const arrowFunction = (program.getSourceFile("/program.ts")!.statements[1] as ts.VariableStatement).declarationList.declarations[0].initializer as ts.ArrowFunction;
        const block = arrowFunction.body as ts.Block;
        const validationResult = validateBlock(block);
        if (!validationResult.success) {
            return validationResult;
        }
        const syntacticDiagnostics = program.getSyntacticDiagnostics();
        const programDiagnostics = syntacticDiagnostics.length ? syntacticDiagnostics : program.getSemanticDiagnostics();
        if (programDiagnostics.length) {
            const diagnostics = programDiagnostics.map(d => typeof d.messageText === "string" ? d.messageText : d.messageText.messageText).join("\n");
            return error(diagnostics);
        }
        const typeChatProgram: ValidatedFunction<T> = {
            functionBodyText,
            block,
            getFunction: () => getIsolatedFunction(functionBodyText)
        }
        return success(typeChatProgram);
    }

    function createProgramFromText(functionBodyText: string, oldProgram?: ts.Program) {
        const fileMap = new Map([
            createFileMapEntry("/lib.d.ts", libText),
            createFileMapEntry("/schema.ts", schema),
            createFileMapEntry("/program.ts", `import { ${typeName} } from './schema';\nconst func: ${typeName} = (${parameterNames.join(", ")}) => ${functionBodyText};`)
        ]);
        const host: ts.CompilerHost = {
            getSourceFile: fileName => fileMap.get(fileName),
            getDefaultLibFileName: () => "lib.d.ts",
            writeFile: () => {},
            getCurrentDirectory: () => "/",
            getCanonicalFileName: fileName => fileName,
            useCaseSensitiveFileNames: () => true,
            getNewLine: () => "\n",
            fileExists: fileName => fileMap.has(fileName),
            readFile: _fileName => "",
        };
        return ts.createProgram(Array.from(fileMap.keys()), options, host, oldProgram);
    }

    function createFileMapEntry(filePath: string, fileText: string): [string, ts.SourceFile] {
        return [filePath, ts.createSourceFile(filePath, fileText, ts.ScriptTarget.Latest)];
    }

    function getIsolatedFunction(functionBodyText: string) {
        const unscopables = Object.create(null);
        const trap = new Proxy(Object.create(null), {
            has(_target, property) {
                // We proxy everything but the parameters of the function.
                return !(typeof property === "string" && parameterNames.includes(property));
            },
            get(_target, property) {
                // The `with` statement looks up unscopables, so we allow that. Otherwise,
                // the only global we recognize is `undefined`.
                switch (property) {
                    case "undefined": return void 0;
                    case Symbol.unscopables: return unscopables;
                }
                throw new Error(`Accessing global '${String(property)}' is not permitted`);
            },
            set(_target, property, _value) {
                throw new Error(`Accessing global '${String(property)}' is not permitted`);
            }
        });
        const func = Function(...parameterNames, `with (this) {
"use strict";
${functionBodyText}
}`);
        return func.bind(trap) as T;
    }
}

function validateBlock(block: ts.Block): Result<true> {
    let errorMessage: string | undefined;
    return block.statements.every(isPermittedStatement) ?
        success(true) :
        error(errorMessage ?? "Function contains an unsupported statement or declaration");

    function invalid(message: string) {
        errorMessage = message;
        return false;
    }

    function isPermittedStatement(node: ts.Node): boolean {
        switch (node.kind) {
            case ts.SyntaxKind.ExpressionStatement:
                return isPermittedExpression((node as ts.ExpressionStatement).expression);
            case ts.SyntaxKind.VariableStatement:
                return isPermittedVariableStatement(node as ts.VariableStatement);
            case ts.SyntaxKind.IfStatement:
                return isPermittedIfStatement(node as ts.IfStatement);
            case ts.SyntaxKind.Block:
                return isPermittedBlock(node as ts.Block);
            case ts.SyntaxKind.ReturnStatement:
                return isPermittedReturnStatement(node as ts.ReturnStatement);
            case ts.SyntaxKind.EmptyStatement:
                return true;
            case ts.SyntaxKind.ForStatement:
            case ts.SyntaxKind.ForInStatement:
            case ts.SyntaxKind.ForOfStatement:
            case ts.SyntaxKind.WhileStatement:
            case ts.SyntaxKind.DoStatement:
                return invalid("'for', 'while' and 'do' statements are not permitted");
            case ts.SyntaxKind.SwitchStatement:
                return invalid("'switch' statements are not permitted");
            case ts.SyntaxKind.TryStatement:
            case ts.SyntaxKind.ThrowStatement:
                return invalid("'try' and 'throw' statements are not permitted");
            case ts.SyntaxKind.FunctionDeclaration:
            case ts.SyntaxKind.ClassDeclaration:
                return invalid("'function' and 'class' declarations are not permitted");
        }
        return false;
    }

    function isPermittedBlock(node: ts.Block) {
        return node.statements.every(isPermittedStatement);
    }

    function isPermittedVariableStatement(node: ts.VariableStatement) {
        if (!(node.declarationList.flags & (ts.NodeFlags.Let | ts.NodeFlags.Const))) {
            return invalid("'var' statements are not permitted")
        }
        if (node.modifiers) {
            return invalid("Modifiers are not permitted on variable declarations");
        }
        return node.declarationList.declarations.every(isPermittedVariableDeclaration);
    }

    function isPermittedVariableDeclaration(node: ts.VariableDeclaration) {
        if (node.exclamationToken || node.type) {
            return invalid("Type annotations are not permitted");
        }
        if (node.name.kind !== ts.SyntaxKind.Identifier) {
            return invalid("Binding patterns are not permitted");
        }
        return !node.initializer || isPermittedExpression(node.initializer);
    }

    function isPermittedIfStatement(node: ts.IfStatement) {
        return isPermittedStatement(node.thenStatement) && (!node.elseStatement || isPermittedStatement(node.elseStatement));
    }

    function isPermittedReturnStatement(node: ts.ReturnStatement) {
        return !node.expression || isPermittedExpression(node.expression);
    }

    function isPermittedExpression(node: ts.Node): boolean {
        switch (node.kind) {
            case ts.SyntaxKind.ConditionalExpression:
                return isPermittedExpression((node as ts.ConditionalExpression).condition) &&
                    isPermittedExpression((node as ts.ConditionalExpression).whenTrue) &&
                    isPermittedExpression((node as ts.ConditionalExpression).whenFalse);
            case ts.SyntaxKind.BinaryExpression:
                return isPermittedExpression((node as ts.BinaryExpression).left) &&
                    isPermittedExpression((node as ts.BinaryExpression).right);
            case ts.SyntaxKind.PrefixUnaryExpression:
                return isPermittedExpression((node as ts.PrefixUnaryExpression).operand);
            case ts.SyntaxKind.PostfixUnaryExpression:
                return isPermittedExpression((node as ts.PostfixUnaryExpression).operand);
            case ts.SyntaxKind.TemplateExpression:
                return (node as ts.TemplateExpression).templateSpans.every(span => isPermittedExpression(span.expression));
            case ts.SyntaxKind.PropertyAccessExpression:
                return isPermittedExpression((node as ts.PropertyAccessExpression).expression);
            case ts.SyntaxKind.ElementAccessExpression:
                return isPermittedExpression((node as ts.ElementAccessExpression).expression) &&
                    isPermittedExpression((node as ts.ElementAccessExpression).argumentExpression);
            case ts.SyntaxKind.CallExpression:
                return isPermittedCallExpression(node as ts.CallExpression);
            case ts.SyntaxKind.ArrayLiteralExpression:
                return (node as ts.ArrayLiteralExpression).elements.every(isPermittedExpression);
            case ts.SyntaxKind.ParenthesizedExpression:
                return isPermittedExpression((node as ts.ParenthesizedExpression).expression);
            case ts.SyntaxKind.ObjectLiteralExpression:
                return (node as ts.ObjectLiteralExpression).properties.every(isPermittedProperty);
            case ts.SyntaxKind.Identifier:
            case ts.SyntaxKind.RegularExpressionLiteral:
            case ts.SyntaxKind.NumericLiteral:
            case ts.SyntaxKind.BigIntLiteral:
            case ts.SyntaxKind.StringLiteral:
            case ts.SyntaxKind.NoSubstitutionTemplateLiteral:
            case ts.SyntaxKind.FalseKeyword:
            case ts.SyntaxKind.NullKeyword:
            case ts.SyntaxKind.TrueKeyword:
            case ts.SyntaxKind.OmittedExpression:
                return true;
            case ts.SyntaxKind.ArrowFunction:
                return invalid("Arrow functions are only permitted as call arguments");
            case ts.SyntaxKind.FunctionExpression:
            case ts.SyntaxKind.ClassExpression:
                return invalid("'function' and 'class' expressions are not permitted");
            case ts.SyntaxKind.NewExpression:
                return invalid("'new' operator is not permitted");
            case ts.SyntaxKind.AwaitExpression:
                return invalid("'await' operator is not permitted");
        }
        return false;
    }

    function isPermittedCallExpression(node: ts.CallExpression) {
        if (node.expression.kind !== ts.SyntaxKind.PropertyAccessExpression) {
            return invalid("Only calls to methods of objects are permitted");
        }
        if (node.typeArguments) {
            return invalid("Type arguments are not permitted");
        }
        return isPermittedExpression((node.expression as ts.PropertyAccessExpression).expression) && node.arguments.every(isPermittedArgument);
    }

    function isPermittedArgument(node: ts.Expression) {
        return node.kind === ts.SyntaxKind.ArrowFunction && isPermittedArrowFunction(node as ts.ArrowFunction) || isPermittedExpression(node);
    }

    function isPermittedArrowFunction(node: ts.ArrowFunction) {
        if (node.modifiers || node.asteriskToken || node.questionToken) {
            return invalid("Arrow function modifiers are not permitted");
        }
        return node.body && (node.body.kind === ts.SyntaxKind.Block && isPermittedBlock(node.body as ts.Block) || isPermittedExpression(node.body));
    }

    function isPermittedProperty(node: ts.ObjectLiteralElementLike) {
        switch (node.kind) {
            case ts.SyntaxKind.PropertyAssignment:
                return isPermittedExpression(node.initializer);
            case ts.SyntaxKind.ShorthandPropertyAssignment:
                return isPermittedExpression(node.name);
            case ts.SyntaxKind.SpreadAssignment:
                return isPermittedExpression(node.expression);
        }
        return invalid("Method and property accessor declarations are not permitted");
    }
}
